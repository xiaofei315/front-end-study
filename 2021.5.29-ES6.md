# let关键字

用来定义块作用域变量的

​			var定义函数级作用域变量的：

​					在函数内部定义的变量，外部无法访问，

​					在代码块（if , of等）中定义的变量，外部可以访问

​			let定义块作用域变量：

​					在函数内部定义的变量，外部无法访问，

​					在代码块（if，of等)中定义的变量，外部仍然无法访问

let与var比较：

|                   | var          | let            |
| ----------------- | ------------ | -------------- |
| 作用域            | 函数级作用域 | 块级作用域     |
| 重复定义          | 可以重复定义 | 不可以重复定义 |
| 声明前置          | 可以声明前置 | 不可以声明前置 |
| for循环中存储数据 | 不能存储数据 | 可以存储数据   |
| 被window挂载      | 可以被挂载   | 不可以被挂载   |

# const关键字

用于定义常量（一旦定义无法改变的变量，通常表示一些固定不变的数据）

| const关键字的特点：                         |
| ------------------------------------------- |
| 1、无法被修改                               |
| 2、支持块作用域                             |
| 3、无法重复定义                             |
| 4、无法声明前置                             |
| 5、不能被window挂载                         |
| 6、不能作为for循环体中的变量使用            |
| 7、值只是值类型，如果是引用类型则可以被修改 |

工作中，通常是将用大写字母表示，并且横线分割单词，常用于定义配置量

在ES5中，我们可以通过冻结对象技术，或者设置writable : false特性，来模拟静态变量

# 字符串拓展

## 多行字符串

单行字符串：由一组单引号或者双引号定义的字符串

| 单行字符串的问题：                       |
| ---------------------------------------- |
| 1、单行字符串不能换行                    |
| 2、一些特殊的按键要是用转义字符 ` \n`    |
| 3、一些特殊的字符要使用转义字符 `\x20`   |
| 4、字符串标志号不能直接嵌套              |
| 5、单引号不能直接写单引号，要转义  ` \'` |
| 6、双引号不能直接写单引号，要转义  ` \"` |

ES6为了解决单行字符串的问题，提供了多行字符串，

```js
通过 " ` " 定义，在多行字符串中，只有" ` "需要转义，其他的字符，都可以直接书写
并且ES6多行字符串支持插值语法：${key}
${ }提供了js环境，因此我们可以写js表达式
ES6的插值语法，让其他框架的差之语法的重要性，大打折扣
```

```javascript
      //并且ES6多行字符串支持插值语法：${key}
	  //  数据
      let size={
        width:20,
        height:10
      }
      //  多行字符串输出 面积：20 * 10 = 200
      let str=`面积：${size.width} * ${size.height} = ${size.width*size.height}`;
      console.log(str);
```

## 原始字符串

在使用了转义字符后，并且在浏览器查看的时候，我们只能看到结果，不能看到原始完整的字符串（包含转义字符），于是ES6中拓展了`String.raw`方法，用于查看原始字符串

使用方法：

```js
String.raw``
```

参数通过多行字符串的形式传递，字符串中的转义字符串不会被转义

## 重复字符串

ES6拓展了repeat方法用于重复输出字符串

​			参数是重复的次数

​			返回值是重复的结果

```js
let str='abc'
console.log(str.repeat(3))//重复三次
```

## 判断字符串位置

`startsWith(str,pos)`

​			是否以参数字符串开头

​			截取后面部分的，并且`包含`截取位置的字符

​			`str`：参数字符串（子字符串）

​			`pos`：字符串截取位置

​			返回值都是布尔值

`endsWith(str,pos)`

​			是否以参数字符串结尾

​			截取前面的部分，并且`不包含`截取位置的字符

`includes(str,pos)`

​			是否包含参数字符串

​			截取后面的部分，并且包含截取位置的字符

## 字符串补全- padStart()、padEnd()

padStart( len, str )、padEnd(  len , str):	接收两个参数:

​				len:字符串补全生效的最大长度

​				str：用来补全的字符串

​				如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。

# 数字拓展

## isNaN( )

全局中有一个`isNaN（）`方法。用于判断是否是NaN

​			全局`isNaN`在判断的时候，会进行类型转换

```js
isNaN()
```



​			而Number拓展的isNaN，在判断的时候不会做类型转换

```js
Number.isNaN()
```



​					首先必须是数字

​					其次采取判断是否是NaN

​							true：表示是NaN

​							false：表示不是NaN

## isFinite( )

全局中有一个`isFinite（）`方法。用于判断是否是有限的（能表示的最大值和最小值之间的数`5e-324~1.7976931348623157e+308`）

​			全局`isFinite`在判断的时候，会进行类型转换

```js
isFinite()
```



​			而Number拓展的`isFinite`，在判断的时候不会做类型转换

```js
Number.isFinite()
```



​					首先必须是数字

​					其次采取判断是否是有限的

​							true：表示是有限

​							false：表示不是有限的

## isInteger

Number拓展的`isInteger( )`方法，用于判断是否是整型

​			判断过程中，会校验类型

​				首先必须是数字

​				其次采取判断是否是整形

​					true：表示是整型

​					false：表示不是整型

# 数学对象拓展

就是对Math的拓展

| ES6 拓展的Math方法 |                                              |
| ------------------ | -------------------------------------------- |
| Math.cbrt          | 计算一个数的立方根                           |
| Math.fround        | 返回一个数的单精度浮点数形式                 |
| Math.hypot         | 返回所有参数的平方和的平方根                 |
| Math.expm1(x)      | 返回ex-1                                     |
| Math.log1p(x)      | 返回1+x的自然对数。如果x小于-1，则返回NaN    |
| Math.log10(x)      | 返回以10为底的x的对数。如果x小于0，则返回NaN |
| Math.log2(x)       | 返回以2为底的x的对数。如果x小于0，则返回NaN  |



| 三角函数方法  |                                                              |
| ------------- | ------------------------------------------------------------ |
| Math.sinh(x)  | 返回x的双曲正弦                                              |
| Math.cosh(x)  | 返回x的双曲余弦                                              |
| Math.tanh(x)  | 返回x的双曲正切                                              |
| Math.asinh(x) | 返回x的反双曲正弦                                            |
| Math.acosh(x) | 返回x的反双曲余弦                                            |
| Math.atanh(x) | 返回x的反双曲正切                                            |
| Math.sign     | 返回一个数字的标志，用来判断数字范围的，   (0，infinity]=>1,                                                   [-infinity,0)=>-1,   0=>0,   -0=>-0,    NaN=>NaN |

# 对象拓展

## 对象字面量

对象字面量：let obj={ }

省略语法：

​			1、如果定义的属性名称与属性值变量同名，我们可以省略名称以及冒号

​			2、可以对属性名称书写表达式，通过`[ ]`来动态的设置属性名称

​					之前可以通过`[ ]`来获取属性，现在我们可以通过`[ ]`来设置属性

​			3、在对象中定义的方法可以省略冒号以及function关键字

## is( )

`is`方法用于判断两个参数是否全等（===）

用法：`Object.is(参数1，参数2)`

全等判断会有两个问题：

​			1、0，-0之前在进行全等判断的时候得到是true

​					0 和 -0之间差了一个符号位，在二进制中，存储的数据是不一样的

​			2、NaN和NaN在进行全等判断的时候，得到的是false

​					所有的NaN都表示“不是一个数字”，存储的地址是一样的

对象拓展的`is`方法：

​			在判断0和-0 的时候，得到false

​			在判断NaN的时候，得到的是true

```js
	//判断
    console.log(0 / 1 === 0 / -1)   //true
    console.log(NaN === +'abc')//false
    //is方法
    console.log(Object.is(0 / 1, 0 / -1))//false
    console.log(Object.is(NaN, +'abc'))//true
	//除此之外，is方法与‘===’一致
```

# assign( )

ES6拓展的`assign`适用于复制对象的，和jQuery、undescore中的extend方法类似

使用方式：`Object.assign(obj,obj1,obj2)`

​			obj：被复制的对象	从第二个对象开始，都是复制的对象	返回值是目标对象obj

​	注意：后面对象的同名属性会覆盖前面的对象中的属性

`assign`方法实现的是一个浅复制

​			浅复制：值类型是直接复制，二引用类型是改变指向，没有真正地复制

​			深复制：值类型时直接复制，引用类型也是直接复制，并不是改变指向（函数除外）

简单实现深复制：`JSON.parse(JSON.stringify)`，但是转换JSON字符串的时候，会过滤掉函数

# 数组拓展

## from( )

`from`方法用于遍历类数组对象，或将类数组对象转换成数组，是数组的静态方法。

​			类数组对象：可以通过索引值获取属性值，并且具备`length`属性的一类对象

类数组对象不能使用数组的遍历器方法，ES6中拓展的`from`方法可以将类数组对象转为真正的数组，之后就可以使用数组的常用方法

使用方法：`Array.from(arrLike,fn)`

​				`arrLike`：类数组对象

​				`fn`：执行的函数，有两个参数：成员值、索引值。作用域是全局作用域（window）

​				如果传递`fn`参数，此时，`from`方法返回值是from函数执行的结果

总结：`from`方法不仅可以将数组转为数组，还可以遍历类数组对象

## of( )

`of( )`方法用于创建数组的，是数组的一个静态方法

​		之前通过`new Array( )`或者`Array( )`创建数组有一些问题：

​				1、如果没有传递参数，得到一个空数组

​				2、如果传递了一个数字参数，得到的是带有一个长度的空数组

​				3、如果传递了一个非数字的参数，得到的是一个带有多个参数的数组

​				4、如果传递了多个非数字的参数，的得到就是一个带有多个参数的数组

ES6拓展的`of()`方法可以实现将所有传递的参数都作为数组中的成员存在

创建数组的四种方法：

​				1、字面量 `[ ]`

​				2、构造函数`new Array( )`

​				3、工厂方法`Array( )`

​				4、`Array.of( )`



## 查找数组

在ES5中拓展了查找成员的方法：`indexOf`、`lastIndexOf`

在ES6中拓展了查找成员的方法：`find`、`findIndex`:

​			参数是执行的函数

​				函数有三个参数：成员值、索引值、原数组。

​				this默认指向window

`find`方法在查找成员的时候，如果找到了则返回该成员，如果没有找到则返回undefined

`findIndex`方法在查找成员的时候，找到了则返回该成员的索引值，没有找到返回-1

在查找过程中，一旦找到则停止遍历

## 数组内部复制

ES6为了实现数组内部复制成员提供了一个方法：`copyWithin( )`

使用方法：

​			`arr.copyWithin(pos,start,end)`

​						`pos`：要粘贴的位置

​						`start`：要复制的起始位置（包含起始位置）

​						`end`：要复制的结束位置（不包含结束位置）

​						返回值是原数组，并且原数组发生变化

## 迭代器方法

ES6中为了遍历数组的成员，拓展了三个迭代器方法：`keys`、`value`、`entries`

​			`keys`:获取索引值

​			`value`:获取成员值

​			`entries`：获取成员值以及索引值：[index,item]

由于实现了数组的迭代器接口方法，就可以使用for of 或者 next 方法来遍历

​		实现了迭代器接口的数据，都有next方法，可以通过next方法来遍历成员。

​				返回值是一个对象：

​						value：表示成员值

​						done：表示是否遍历完成

​				如果遍历完成了，此时：done将永远是true； value将永远是undefined

##  for of 循环

for  of 循环是ES6专门为实现迭代器接口的对象设计的循环接口

语法：`for(let item od data){ }`

可以向其他循环一样在内部使用continue、break等关键字

for of也可以是遍历数组的，但在遍历过程中无法使用索引值

​			遍历数组的时候，item表示数组的每一个成员，没办法访问索引值，但是我们可以在外部定义一个循环变量，再循环遍历数组的时候，不需要通过索引值访问成员，而for循环以及for in循环需要通过索引值访问

​			for in也可以遍历数组，但是有一些问题：便利的时候，key显示的是字符串，不是数字

总结：for循环用于遍历数组，for in 循环用于遍历对象，for of 循环遍历实现了迭代器接口的对象（包括数组）

# 解构

## 解构定义

所谓解构就是解析聚合数据的解构

​			在ES5中的聚合数据有：对象、数组

​			在之前，对象获取的方法只有通过点语法或中括号语法2

​			在之前，数组获取数据的方法只能通过中括号语法

在ES6中建华了获取数据的方法，提供了解构语法：对象解构和数组解构

## 对象解构

语法：`let {key1,key2,key3,...keys} = obj`

​			`key1`：相当于`obj.key1`

​			`key2`：相当于`obj.key2`

​			`keys`：获取的是剩余的变量，如果没有剩余的属性，获取到的是一个空对象

注意：解构出来的属性、变量一定是和对象中的属性是同名的

解构问题：

​			1、如果使用var解构会污染全局对象（window），我们可以使用let关键字解决

​			2、解构出来的方法，方法中的this将发生变化

​			3、对于引用类型来说，只是指向的改变，而对于值类型来说，是真正的复制

逆运用：

​			我们可以通过三个点语法，将一个对象中的所有数据传递给一个对象字面量中：

​			`{ ...keys }`

注意：由于解构出来的数据会污染全局变量，因此工作中常常配合模块化去开发（相当于局部变量）

## 数组解构

语法：`let [item1, item2, item3, ...items]=arr`

​			`item1`：表示第一个成员

​			`item2`：表示第二个成员

​			`items`：表示剩余的成员

​			注意：`item1`和`item2`中有对应的成员返回该成员，没有则返回undefined

注意：如果使用var解构会污染全局对象（window），我们可以使用let关键字解决

获取剩余成员的语法：

​			1、如果数组有剩余成员，获取到的是数组中所有的剩余成员

​			2、如果没有剩余成员，获取到的是一个空数组

​			3、前面解构的变量，可以正常使用

逆运用：

​			我们可以通过三个点语法，将一个数组中的所有数据传递到一个数组字面量中，`[...arr] `   (复制数组)

## 解构总结

解构指的是等号左侧的部分

逆运用是等号右侧的部分

​			例如：复制数据

解构：

​			对象解构，属性名称匹配

​			数组解构，索引值匹配（位置对应）

# 函数拓展

## 默认参数

在之前的适配默认参数的方式：

​			1、可以通过`||`运算符来适配参数的默认值

​						但是使用`||`运算符会忽略6个值为`false`的参数：`0`、`''`、`undefined`、`null`、`false`、`NaN`

​			2、可以使用三元运算符：`?  : `，如果参数过多，书写比较麻烦

​			3、使用`extend`、`assign`方法适配对象，对于值类型的参数不适用

在ES6中为了解决这样的问，提供了适配默认参数的方法，直接在参数集合中为形参赋值即可

​			1、如果传递了参数，则使用传递的参数

​			2、如果没有传递参数，则使用默认参数

ES6拓展的适配默认参数的方法与三元运算符的方法是等价的

## 获取剩余参数

之前我们可以通过arguments来获取所有参数，但是arguments是一个类数组对象，不能使用数组的常用方法。

于是ES6拓展了获取剩余参数语法，获取的剩余参数是一个数组，所以可以直接使用数组的常用方法

语法：`function demo(arg1,arg2,...args){ }`

​				1、`arg1`：表示第一个参数

​				2、`arg2`：表示第二个参数

​				3、`args`：表示剩余参数

获取剩余参数的语法：

​			1、如果有剩余的参数，获取到的是一个由所有剩余参数组成的数组

​			2、如果没有剩余参数，获得的是一个空数组

​			3、前面参数可以正常使用，前面的参数如果没有对应的参数则是undefined

​			4、在箭头函数中有广泛的应用

获取剩余参数的逆应用：

语法：`demo(...args)`

我们可以通过`apply`方法，将数组中的每一项传递到一个方法中

​			但是使用`appply`方法需要考虑this的指向问题

可以使用获取剩余参数的语法，就不需要考虑this的指向问题了，正常执行函数

```js
	//获取剩余参数的语法求和
    function add(...nums) {
        //通过数组的方法求和
        return nums.reduce(function (res, item) {
            return res + item;
        });
    }
    //获取剩余参数 的逆运用
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    //通过apply
    let result1=add.apply(null,arr)
    //通过获取剩余参数的语法
    let result2=add(...arr)
```



## 箭头函数

在ES5中定义函数的方法：1、函数定义式；2、函数表达式；3、构造函数式

在ES6中有拓展了一种方法：箭头函数。

```js
	//  函数定义式
    function demo1() {
        console.log('demo1');
    }
    //  函数表达式
    let demo2 = function () {
        console.log('demo2');
    };
     //  构造函数式
    let demo3 = new Function('console.log("demo3")');
    //箭头函数
    let demo4 = () => {
        console.log('demo4');
    }
```

语法：`let demo = ( ) =>{ }`

​			`( )`：表示参数集合

​			`=>`：是箭头函数的标志

​			`{ }`：是函数体

几点省略语法：

1、如果参数集合中只有一个参数，即可省略参数集合

```js
	//1、省略参数集合
	let print =msg =>{
        console.log(msg);
    }
    print('hello')
```



​			如果使用`...`三个点语法获取剩余参数或者解构语法，不能省略参数集合

```js
	//2、获取剩余参数语法不能省略参数集合
    let print =(...args)=>{
        console.log(...args)
    }
    print(true,'123',123)
	//3、解构语法不能省略
    let print = ({msg}) => {
        console.log(msg)
    }
    print({color: 'red',msg:'hello'})
```



2、如果函数中只有一句话，或者只有返回值的时候，可以省略return以及函数体

```js
	//省略函数体
    let arr = [1, 2, 3, 4, 5];
    //数组映射
    let result =arr.map((item)=>{
        return Math.pow(item,2)
    })
    //省略函数体
    let result=arr.map(item=>Math.pow(item,2))
    console.log(result)
```



箭头函数的特点：

1、无法使用arguments，但是可以使用三个点语法获取剩余参数

2、无法作为构造函数使用

3、箭头函数的this永远指向定义时的

​			无论使用call、apply或者是bind方法都无法改变箭头函数的作用域

​			改变箭头函数的作用域唯一的方法即使改变其宿主环境作用域

​			也就是改变外部作用域



# Symbol类型

在JS中有6种数据类型：数字、字符串、布尔值、undefined、null、object

在ES6中添加了一种新的数据类型：Symbol数据类型，表示独一无二的数据

​			我们可以通过`Symbol`方法创建`Symbol`数据，参数就是对`Symbol`数据的描述，但是结果不受影响

​			我们可以通过`typeof`查看`Symbol`数据类型，如果参数传递的是对象，默认会调用其`toString`方法

`Symbol`数据类型的出现是为了避免对象中同名属性被覆盖的问题

​			我们通过`Symbol`创建的额数据类型，就可以避免对象中同名属性被覆盖的问题

​			`Symbol`创建的数据不能通过`for in`的方式查看，也不能通过`Object.keys`查看数据

​			只能通过`Object.getOwnPropertySymbols`查看数据(`Object.keys`用来获取对象中所有的属性数据的)

​			还可以通过变量，查看对应的数据类型

```js
//Object.keys                   获取自身属性（不包括：不能枚举的，以及symbol属性）
//Object.getOwnPropertySymbols  获取自身symbol属性（不包括：普通属性以及设置了特性的属性） //Object.getPropertyNames       获取自身属性，可以获取不能枚举的属性（不包括：symbol属性）
```



# 代理-Proxy

在一个系统中，总要在一个对象中，存储一些数据，对于这些数据，可能有一些是希望我们访问的，但是总有一些是重要的，不希望我们访问的，希望保护起来，因此ES6新增了代理，实现这一特征

语法：通过`Proxy`实现：

​			`let proxy = new Proxy(obj,{set,get})`

​					第一个参数：`obj`表示被代理的对象

​					第二个参数：`{set , get}`表示操作被代理对象的对象 

​					`get(obj,key)`：表示取值方法：

​							`obj`：表示被代理的对象			`key`：表示获取的属性

​							返回值：就是获取的数据			`this`指向操作对象						

​							注意：绝对不能获取代理对象（proxy）的key属性

​					`set(obj, key, value)`：表示赋值方法：

​							`obj`：表示被代理的对象			`key`：表示修改的属性	

​							`value`：表示修改的属性值		`this`:指向操作对象

​							不需要返回值

​							注意：绝对不能在里面修改代理对象（proxy）的key属性

代理跟特性很像：

​			特性是对同一个对象的操作，数据不能在当前属性下存储，存储在备份中

​			代理是对不同的对象的操作，数据可以直接存储在当前属性下，原对象没有发生改变



# 反射-Reflect

`Reflect`是对对象中的一些操作方法的封装

在之前，对象中的所有方法都给了`Object`，这些方法属于内部语言方法，于是将这些方法拿出来给了`Reflect`，因此以后调用这些方法方法的时候，可以通过`Reflect`来调用

所以在未来对象的方法可能被移除，给了`Reflect`。例如：

​		在之前定义特性的方法：`Object.defineProperty`，现在定义特性的方法：`Reflect.defineProperty`

`Reflect`允许对一些操作符当做方法去执行：

​			`has`：代替`in`运算符，检查某个属性是否存在	

​			`deleteProperty`：删除对象中的某一个属性

​			`getOwnPropertyDescriptor`：获取某个属性的描述特性对象	

​			`get`：获取数据			

​			`set`：设置数据

# 聚合数据

在ES5中的聚合对象有：对象和数组

在ES6中又添加了四种聚合数据：`Set`、`WeakSet`、`Map`、`WeakMap`

​	所以ES6中有六种聚合聚合数据：对象、数组、`Set`、`WeakSet`、`Map`、`WeakMap`

## Set

`Set`是实现了迭代器接口的去重数组

​			在去重的时候不会做类型转换，

​			由于`Set`对象实现了数组迭代器接口，所以可以使用`for  of`语句遍历该对象

内部提供了大量的方法用于操作该对象，属性以及方法如下：

​		`size`：获取数据的长度			`has`：判断是否包含某个属性

​		`add`：添加数据						`delete`：删除某项数据

​		`clear`：清空数据					`forEach`：用于遍历数据

​		`keys`、`vlaues`、`entries`：用于获取迭代器接口

```js
	let s=new Set([1,2,1,2,3,4,3,4])
    console.log(s)
    console.log(s.size)
    console.log(s.add(9))//添加
    s.delete(2);//删除
    console.log(s.has(2));//判断是否包含
    console.log(s.clear())
    //遍历
    s.forEach((...args)=>console.log(args))
    console.log(s.values())
    console.log(s.keys())
    console.log(s.entries())
    for (let item of s) {
        console.log(item)
    }
```



## WeakSet

WeakSet对象是弱set对象，成员只能是引用类型

​			注意：不能添加空对象null

由于是弱set对象，因此存在的方法较少，只有添加`add`、删除`delete`、判断`has`是否拥有三个方法

其他的`size`属性，`forEach`、`clear`、`keys`、`entries`、`values`等方法都不存在

内部提供的方法：

​			`delete`：删除数据

​			`has`：判断是否包含某个属性

​			`add`：添加属性

由于WeakSet不能被垃圾回收机制自动收回，因此要慎用。

## Map

Map是一个超级对象

​			传统的对象所有的属性名称都必须是字符串

​			但在Map对象中，定义的属性名称可以是任意类型（7种类型都可以）

​			通过new map 创建 map对象，实现了迭代器接口对象，因此可以使用for of循环遍历

内部提供了大量的方法用于操作该对象，属性以及方法如下：

​			`size`：获取数据的长度			`has`：判断是否包含某个属性	

​			`delete`：删除某项数据			`clear`：清空数据	

​			`get`：获取数据							`set`：设置数据	

​			`forEach`用于遍历数据				`keys`、`values`、`entries`：获取迭代器接口

## WeakMap

WeakMap对象是弱map对象，属性名称只能是引用类型的数据

​		注意：不能添加空对象null

由于是弱map对象，一次少了很多方法，只有`set`、`get`、`delete`、`has`方法，

其他的`size`属性，`forEach`、`clear`、`keys`、`entries`、`values`等方法都不存在

内部提供的方法：

​			`delete`：删除数据

​			`has`：判断是否包含某个属性

​			`get`：获取数据

​			`set`：设置数据

由于WeakSet不能被垃圾回收机制自动收回，因此要慎用。

# 迭代器接口

在ES6中，只实现了迭代器接口（`Symbol.iterator`)，并没有实现迭代器接口类，有四种情况会实现迭代器接口

​			1、使用迭代器接口方法的时候，如`keys`、`values`、`entries`等

​			2、在解构的时候

​			3、在创建map、set对象的时候

​			4、在使用for  of循环的时候

迭代器的作用：

​			1、定义了我们访问数据的次序

​			2、为for of 提供了访问数据的方式

​			3、让所有数据具备统一的接口，方便快捷的获取数据

# Promise

Promise是将异步写法变为同步写法的规范

​			只是写法的改变，操作并没有改变

​			异步写法：在回调函数中，一层嵌套一层

​			同步操作：将方法写在外部

三个状态：

​			`pending`：表示操作正在执行

​			`resolved`：表示操作执行成功

​			`rejected`：表示操作执行失败

状态的流向：

​			状态由`pending`流向`resolved`，说明操作执行成功完毕

​			状态由`pending`流向`rejected`，说明操作执行失败完毕

语法：

​		`new Promise((resolve,reject) = > {回调函数中执行异步操作})`

​			如果执行成功，执行`resolve`方法

​			如果执行失败，执行`reject`方法

在外部通过`then`方法监听状态的改变

​		`then(success,fail)`：该方法接收两个参数（回调函数）

​			`syccess`：表示成功时候执行回调函数，参数是由`resolve`方法执行的时候传递的参数(只能传递一个)

​			`fail`：表示失败时候执行回调函数，参数是由`reject`方法执行的时候传递的参数(只能传递一个)

`then`方法的返回值是`Promise`对象，因此可以链式调用该方法

上一个`then`方法的输出，将作为下一个`then`方法的参数输入。如果存在执行完毕，`then`方法也会立即执行

## Promise规范--监听状态

有三个方法可以监听Promise状态：

​		`then`：可以监听状态成功或者是失败的方法，

​						后一个`then`方法可以监听前一个`then`的成功与失败

​		`catch`：可以监听状态失败时候的方法，失败只能被监听一次，但是可以被后面的`then`继续监听

​		`finally`：无论成功或是失败都会执行的方法，无法接收数据



## Promise规范--all

`all`方法用于监听多个Promise对象

​			参数是一个数组，数组中的每一项都是一个Promise对象

我们可以通过`then`方法监听状态的改变

​			如果所有的操作执行成功，才会去执行success方法

​			如果有一个操作执行失败，则会执行fail方法

​			不论成功或是失败，返回值都是数组，数组中的每一个成员对应每一个promise返回的数据

##  Promise规范--race

`race`方法用于监听多个Promise对象

​		参数是一个数组，数组中的每一项都是一个Promise对象

我们可以通过`then`方法监听状态的改变（监听第一个promise对象状态的改变）

​			如果有一个请求执行成功，就会去执行success方法

​			如果有一个请求执行失败，就会执行fail方法

​			返回值是状态改变的时候传递的数据

##  Promise规范--resolve 与 reject

`resolve`是Promise的静态方法，返回一个可以监听resolve状态的promise对象

​	参数有三种：

​			`js`数据，此时then方法会立即（`then`方法接收的数据就是该数据)

​			`Promise`对象

​			`thenable`参数（带有then方法的对象）

`reject`是Promise的静态方法，返回一个可以监听`rejected`状态的对象

​			`then`方法监听失败的时候，回调函数的参数是`reject`方法的参数（错误信息的描述）

​			不论`reject`方法是什么数据，`then`都将执行失败的回调函数



# `generator`

## `generator`函数

`generator`函数为了处理异步编程提供了解决方案（异步函数），允许我们逐条遍历

语法：`function *demo( ){ 函数内定义状态 }`

在函数内部通过`yield`关键字定义状态，`yield`表示暂停的意思

​			注意：`yield`关键字只能出现在`generator`函数中

通过`return`定义最后一个状态，`return`后面的状态不会执行

`generator`函数的返回值实现了`next`方法，因此可以通过`next`方法逐条遍历内部的状态

​			`next`方法的返回值是一个对象

​					`done`属性：表示是否遍历完成

​					`value`属性：表示状态值

`next`方法返回的是一个状态对象

​		如果有状态的情况下，`done`是`false`，`value`是`状态值`

​		如果没有状态，`done`是`true`，`value`是`undefined`

`generator`函数的返回值也实现了迭代器接口，因此也可以通过for of方法遍历内部的状态，但是不要使用两种方法去遍历内部的状态，因为，一方遍历完成，另一方就得不到状态了

当`generator`函数遍历完成之后，此时它的状态变为`closed`

当`generator`函数没有遍历完成的时候，此时它的状态变为`suspended`



## `generator`函数--数据传递

在`generator`函数中数据的传递有两个方向：

​			1、数据由`generator`函数的内部向外部流动

​			2、数据由`generator`函数的外部向内部流动

数据由内部流向外部

​			1、通过`yield`表达式定义状态值

​			2、在外部通过`next`方法返回的对象中的`value`属性获取

数据由外部流向内部

​			1、在外部通过`next`方法传递数据

​			2、在内部通过`yield`表达式接收数据



## `generator`函数--return方法

`return`：

​			在`generator`函数的原型中提供了`return`方法，用于在外部停止内部状态的遍历

​			如果在函数体中出现了`finally`语法，`return`语句将会延后执行



## `generator`函数--throw方法

`throw`：

​			在`generator`函数的原型中提供了`throw`方法，允许在外部抛出错误

​			为了代码正常执行，我们可以在状态函数体中通过`try catch`语句去捕获错误

​			如果外部抛出了两个错误：

​				第一个错误在状态函数体外通过`try catch`语句去捕获第一个错误

​				第二个错误在状态函数体外通过`try catch`语句去捕获第二个错误

## `generator`函数--yeild*、this、`...`语法

`yield*` 语法：

​			可以将函数内部的状态复制到另一个函数体内执行

`...`语法：

​			使用`...`语法解构是，可以将一个函数体中的所有状态值获取到

`this`:

​			在`generator`函数中的this指向window

​			所以，不能通过this去添加任何属性以及方法

​			如果想要添加属性或者方法，我们可以在执行函数的时候，使用`call`、`apply`方法改变其作用域，将其指向函数 的原型



# `async`和`await`

`async`和`await`是ES2016（ES7）中提出的，可以认为是generator函数的语法糖

语法糖：对一些复杂操作的简化，可以使我们用更简单的方法去操作，提高了开发效率

​			`async`：表示函数中有异步操作，代表了`*`语法

​			`await`：表示等一等的意思，只有当前程序执行完成之后，后续代码才会执行，代表了`yield`关键字

特点：

​			1、提高了代码的语义化					

​			2、`await`返回值是`Promise`对象

​			3、`await`后面允许是任何数据		

​			4、在函数中内置状态函数的启动，直接执行函数即可，不需要通过`next`方法执行

​			5、`generator`表示状态机，`aync`定义的是异步函数



当程序执行到`await`的时候，会交出出现的控制权，只有当异步操作执行完毕后，后续的代码才会执行

​			如果`await`后面出现了其他数据，会返回一个监听`resolved`状态的`promise`对象

​			如果函数中出现了错误，会将错误信息追踪到错误队列中

返回对象：

​			`await`返回值是一个`promise`对象

​					可以使用`then`方法监听成功时候状态

​					可以通过`catch`方法监听失败时候的状态

​			`await`和`yield`一样：

​					`await`只能出现在`async`中			`yield`只能出现在`generator`函数中

# 类

在ES6中实现了类。语法：`class 类名 {}`

​		ES6 之前定义类的方法：`function People(title){this.title =title;}`

在类体中可以定义三类数据：

​		第一种实例数据：

​				可以通过`constructor`构造函数定义自身属性或者方法，这类数据会被当前实例化对象所访问

​		第二种原型数据：

​				我们直接在类体中定义原型方法即可。

​				如果定义原型属性数据，则必须要用get、set设置特性的方式来定义：get取值器、set赋值器

​				由于对数据设置了特性，在查看对象的时候，这些数据将展示在自身

​		第三种数据：静态数据（通过类直接访问，二实例化对象不能访问的）

​				定义静态数据的方式有两种：

​						1、直接在类体中，在数据的前面加上static关键字即可

​						2、在类体外，直接为类添加数据

​				区别：

​						在类体中添加的静态数据，设置了特性

​						在类体外添加的静态数据，没有设置特性

# 继承











# 编译ES6

随着ES6，ES6+等新标准的出现，为了更好地开发体验而要使用这些新特性，但是在浏览器中又不能直接运行，所以我们就需要一个编译工具来讲代码编译成浏览器支持的版本，这就是babel编译器

安装node之后，可以全局安装babel指令：`npm install -g babel-cli`

配置`.babelrc`文件

​			通过presets配置项定义编译器

​			安装ES6的babel插件：`npm install babel-preset-es2015`

编译文件

​			输出到控制台：`babel 文件`

​			输出到文件中：`babel 文件 --out-file 路径+文件名`





















