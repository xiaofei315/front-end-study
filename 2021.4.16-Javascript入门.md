## JavaScript概述：

### **前端的三层：**

结构层：HTML			网页结构

样式层：CSS			美化页面

行为层：JavaScript			交互行为

### **用途：**

数据验证、读写HTML元素、与浏览器及其内容的交互效果、网页特效、web游戏制作、基于Node.js技术进行服务器编程

### JavaScript由ECMAScript、DOM、BOM三部分组成。

### JavaScript是一门弱类型动态的脚本语言：

行内式：在元素的时间属性中书写

内嵌式：书写在body标签内部的一对script 标签中，script 标签有一个属性type，属性值是“text/javascript”:表示书写的是纯文本的JavaScript语言（学习中常用）

外链式：通过外部引入js文件，将引入文件写在head标签内部（工作中常用）

js脚本语言不能直接在浏览器中加载，必须依托HTML载体实现。

## 字面量：用于表达一个固定值的表示法。也叫做直接量、常量，字面量可用于表示固定值

### 数值字面量：整数、浮点数、特殊值

```
整数字面量：
    十进制是最基本的数值字面量格式，可以直接在代码中输入
    八进制字面值必须带有前导0、0o、0O
    十六进制的前缀是0x或0X
```

```
浮点数字面量：
	浮点数：整数部分+小数部分
	幂的表示法：如（1.2e10）
	只有十进制，没有八进制和十六进制
	两个特殊值：
		infinity：表示无穷大
		NaN：not a number，不是数字，但本身是数字的字面量
```



### 字符串字面量：

```
	字符串可以使用一些特殊字符（转义字符）：
		\n：换行
		\t：tab制表符
		\'：单引号
		\"：双引号
		\\：反斜杠
```

## 变量声明：

变量声明，也定义变量或者创建变量，可以用来保存任何类型的数据；

变量必须先声明再使用；

变量名本身也叫标识符，任何标识符的命名都要遵守一定的规则：`只能使用字母、下划线（_）、美元符号（$）或者数字，但不能以数字开头`，JavaScript语言是区分大小写的；

关键字：拥有特殊功能的小词语

保留字：也是单词，本身没有功能，但是将来可能作为关键字

## 变量声明的提升：

### 概念：

可以引用稍后声明的变量，并且不会引发异常；

### 解释：

JavaScript变量被提升到了所有函数和语句之前。然后提升的语句将返回undefined值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到undefined值

### 原理：

如果我们先引用一个变量变量在后面定义，计算机会有一个预解析的过程，会去全局范围内查找是否有定义过变量，会将所有的定义的变量的声明提升到所有代码的前面。后面加载代码的时候，能够找到这个定义的变量

变量声明提升：只提声明（定义），不提升赋值。

## 数据类型：

不管是字面量、变量、函数、数组，都有自己的数据类型。

### 简单数据类型

- undefined - 如果变量是 Undefined 类型的

- boolean - 如果变量是 Boolean 类型的

- number - 如果变量是 Number 类型的

- string - 如果变量是 String 类型的

- object - 如果变量是一种引用类型或 Null 类型的

  

## 数据类型转换：

数字转字符串（数字+空字符串）：这个‘+’表示连接符

注意：数字和数字类型之间是正常的运算符

### 字符串转数字：

```javascript
parseInt()有两个参数;
	    第一个参数要的转字符串（可以省略前缀）：parseInt("abc");
        第二个参数：进制（0,10以及默认值都是10进制，最高36进制）:parseInt(123,10);
        作用：
        	1.对数字进行取整
            2.会保留字母前面的数字
            3.如果字母前面没有数字，将得到NaN
        
parseFloat();
		将字符串转换为浮点型，
        没有进制转换
“+”：可以将字符串转换为数字；
		+'12.3'//12.3
		+'12a.2'//NaN
		+'0X11'//17
```



# 2. 运算符、

## 数学运算符：

### 数学运算符：

```
加：+
减：-
乘：*
除：/
求余：%
```

### 特殊运算：

```
   1.纯数字字符串与数字进行运算的时候，纯数字字符串会被隐式的转换为数字参与运算，加法除外。
   2.除了纯数字之外，还有布尔值和null会被隐式转换：
   例如：true->1;false->0;
   		null->0;"123"->123。
   3.非纯数字字符串和undefined，不能进行隐式转换，与任何数字进行运算都得到NaN
   4.任何数字和NaN运算都得到NaN。
```

### Math对象：

```
常用的方法：
	Math.random():	返回一个大于等于0小于1的一个随机数
    Math.pow(num,power):	返回num的power次幂
    Math.sqrt(num):	返回num的平方根
    Math.PI:	返回π的值
```





## 比较运算符：

### 比较运算符：

```
>：大于
<：小于
>=：大于等于
<=：小于等于
==：等于，尽可能的去判断两边相等
！=：不等于
===：全等于，值和类型都要相等
！==：不全等于
```

### 特殊字符串与数字比较：

```
	比较过程中：纯数字字符串会被转换成数字，true会被转换成1，false转换成0，null转换成0；
	注意：做相等和全等的时候null不会被转换成0。
```

### 字符串与字符串比较：

```JavaScript
	比较的是字符的Unicode编码顺序。顺序靠前的小于顺序靠后的。
	charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。
	字符串中第一个字符的位置为 0， 第二个字符位置为 1，以此类推。例如：（'a'.charCodeAt(0)//97）
	字符编码顺序：数字、大写字母、小写字母
	
```



## 逻辑运算符:

### 逻辑运算符:

```
&&:逻辑与运算符
||：逻辑或运算符
 !：逻辑非运算符
```

### 特殊情况：

其他非布尔值也可以参加逻辑运算，参与的时候，会自动转换成布尔值进行运算，返回的结果就不一定是布尔值。

**`提示：'!!'可以将任何数据转换成布尔值`**

NaN、0、null、“”、undefined会转换成false参与运算。

非0数字、非空字符串都会转成true参与运算

注意：&&的优先级高于||，建议使用（）提升优先级

## 赋值运算符：

### 赋值运算符：

```
=
+=
-=
*=
/=
%=
++
--
```

### 综合运算：

顺序：贴身的（！、++、--）-> 数字运算符->比较运算符->逻辑运算符->赋值运算符

## 按位运算符、

## 条件（三元）运算符、

# 3. 条件语句与循环语句：

## for循环：

## while循环：

## do-while循环：

# 4. 函数详解：

## 函数的参数：

### 函数声明：function +函数名+（参数集合-形参）{ }

注意：形参也是变量，命名规则和变量一致

### 函数调用：函数名（传递参数-实参）

形参和实参的个数可以不相同：

​	1.如果实参的个数多余形参的个数，那么多余的实参会被舍弃

​	2.如果实参个数少于形参的个数，则优先将实参赋值给前面的变量。

arguments：arguments是函数自带的属性，是由实参组成的类数组对象。

js是一门动态类型数据语言，变量的数据类型根据存放的内容而变化

​		实参的数据类型直接影响形参的数据类型；

​		实参可以传任意类型的值。

## return：

函数可以用变量来接收参数，还可以使用return关键字来返回数据。

作用：返回数据

返回值将我们的函数转换成了一个表达式。利用这个特性，我们可以将函数作为一个实际参数，传递给另外一个函数。

函数内部遇到return会立即返回，也就是结束函数的执行，return后面还有其他的语句都不执行。

函数的优点：可以将一个函数的返回值，传递给另外一个函数。有利于我们的模块化编程。

函数执行完毕有两种情况：

默认：没有结果

通过return返回：有结果

## 函数表达式：

### 函数声明使用function

还可以使用函数表达式：

```javascript
语法：let fun = function(){}
就是将一个匿名函数赋值给一个变量。匿名函数后面的括号也可以书写参数。
```

匿名函数也叫拉姆达函数。

注意：函数定义式定义的函数后面不需要加分号，而函数表达式形式定义的函数，后面必须加上分号；函数的调用和之前的一样：函数名（）。

## 函数的数据类型

不管是函数表达式还是函数定义式，通过typeof查看都是function。

总结：简单数据类型赋值的是值，引用类型赋值的是地址

## 函数声明的提升:

函数也可以先使用，后声明。因为计算机在预解析的时候，先将函数的声明提升到语句的最前面，并且将函数的定义全部提升到了最前面；

注意：函数定义式会提升整个函数；函数表达式只会提升变量的声明

所以在实际工作中一般使用function关键字定义函数，而不是使用函数表达式，以防出错。

我们习惯先调用函数，将函数的声明放在最后面，使代码清晰可读

JavaScript运行主要分为词法分析和执行两个阶段：

​	词法分析主要分为3步：第一步：分析形参；第二步：分析变量声明；第三步：分析函数声明

注意：如果存在函数嵌套，则从外往内进行词法分析

## 声明提升的原理：

### 具体步骤：

在函数执行的一瞬间，产生Active Object（活动对象|容器），简称AO。函数声明的形参，形成AO的属性（放在容器中），默认值是undefined：

接收实参，给刚刚形成的AO的属性的形参赋值

分析let声明的变量，如let dafei；（变量的值是在运行时期决定的）：

​		如果AO上没有dafei属性，则给AO添加dafei属性，默认值是undefined；

​		如果AO上已经有dafei属性则不做任何操作。

分析函数声明，如：function demo（）{  }：

​		如果AO上没有demo属性，则把函数赋给AO.demo属性；

​		如果AO上有demo属性，则会直接覆盖，把函数赋给AO.demo属性执行；执行函数的时候，如果声明的变量有赋值的操作，则为变量赋值。

为了避免这类问题，尽量不要让函数，变量，形参重名

## 递归函数：

一般用来解决数学问题

递归函数：在函数内部调用自身

通常会设置一个临界条件，当达到该条件的时候，停止递归调用



## 作用域链

### 变量的作用域：

在函数中声明的变量，只能在函数内部使用，在函数外部任何地方都不能访问这个变量。

在JavaScript中只有函数能关住变量

### 作用域链

是指变量查找的规律：我们可以在不同的作用域内使用相同的标识符去命名变量。在使用一个变量的时候，需要找到匹配的标识符，有重复的标识符，该用哪一个？如果当前作用域有这个变量，就直接使用，如果当前作用域没有这个变量，会一层一层的从本层向外一次查找，查找会在找到第一个匹配的表示符的时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生“遮蔽效应”|

如果变量声明时，不写var，let关键字，计算机会自动在全局作用域内给它进行一次声明，局部变量就强制转换成了全局变量。会造成全局变量的污染。

函数的作用域：函数的作用域和变量类似，也是只能在声明函数的地方进行调用，在任何外部地方都不能使用

### 闭包：

#### 闭包的定义：

闭包是指有权访问另一个函数作用域中的变量的函数

内部函数把它自己内部的语句，和它声明所处的作用域一起封装成了一个密闭的环境，我们称之为“闭包”，函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参与定义时的密闭环境。

闭包天生存在，并不需要什么特殊的结构才存在，只不过我们必须要刻意地把函数放到其他的作用域中调用，才能明显的观察到闭包的性质。

闭包能够记住外部的环境和内部的语句。但是外部环境并不是一成不变的，每一次函数的调用都产生一个全新的闭包。函数的密闭，里面的内部语句和外部环境都是全新的

#### 闭包的作用：

外部函数可以起到封闭空间，存储数据的作用，供闭包使用。

闭包无法被js垃圾回收机制自动回收

注意：闭包函数本身具有一个作用域，因此与外界产生命名冲突的时候，根据作用域链原则，会优先使用内部的数据

闭包的数据没有办法被销毁

## IIFE：

### IIFE:（immediately-invoked function expression）。即时调用函数表达式。

IIFE表示在函数定义的时候，就立即执行。

在函数后面添加小括号。小括号表示函数调用。小括号只能用在函数名或者函数表达式后面。

需要将函数矮化为函数表达式。可以使用数学运算符。比如：+、-、！、（）（'（）'最常用）

一般使用小括号将函数包裹矮化为函数表达式。并且一般我们直接匿名函数。

注意：转换成表达式后，在后面添加" ; "。否则几个表达式运行在一起会报错

IIFE能管住函数的作用域。在IIFE外部任何地方都不能访问到。

**IIFE实际参数书写在立即调用小括号中。**

IIFE本身相当于是表达式，如果内部有return关键字，IIFE可以作为数值参与其他运算（函数）

# 5. 数组类型：

## 数组概述：

## length属性：引用数据类型一般都有length属性

`arr.length`**获取数组的长度**

引用数据类型可以具有方法、属性：

方法：对象具有的动作

属性：对象具有的特征

强制数组拉长：
								1、通过length拉长数组长度，中间的数组的没有赋值，输出结果是undefined

​						2、通过下标拉长数组，此时数组被拉长（有序拉长）

​						3、通过大于length的下标设置数组成员，就是一种无规律拉长

## 数组方法：

| 数组方法：                                   |                                                              |
| -------------------------------------------- | ------------------------------------------------------------ |
| Array.pop()                                  | 删除数组的最后一项。不用书写参数，返回删除的值               |
| Array.push(参数1、2……)                       | 在数组最后面添加数据。参数：是要添加的数据，多项用逗号隔开。返回值：数组的长度 |
| Array.shift()                                | 删除第一项。不用写参数，返回删除的值                         |
| Array.unshift(参数1、2……)                    | 数组开头添加数据。参数：盐田家的数据，多项用逗号隔开。返回数组的长度 |
| Array.concat(arr1,arr2...)                   | 合并两个或多个数组，生成一个新的数组。原数组不变。           |
| Array.join()                                 | 将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号 |
| Array.reverse()                              | 将数组倒序。原数组改变                                       |
| Array.sort()                                 | 对数组元素进行排序。按照字符串UniCode码排序，原数组改变。    |
| Array.splice(index,howmany,elemt1,elemt12……) | index：删除数组的首项的索引值；howmany：删除的个数；,elemts:替换或插入的元素。返回被删除的元素组成的数组，原数组变化 |
|                                              |                                                              |
|                                              |                                                              |

堆栈与队列：

堆栈(最后一个元素后进先出)：push - pop ;    

队列(最后一个元素后进后出，第一个元素先出): push - shift

**Array.sort方法的原理：**

```
如果要得到自己想要的结果，不管是升序还是降序，就需要提供比较函数了。该函数比较两个值的大小，然后返回一个用于说明这两个值的相对顺序的数字。

比较函数应该具有两个参数 a 和 b，其返回值如下：

若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。

若 a 等于 b，则返回 0。

若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。
```

## 通过数组观察闭包：

闭包：函数天生闭包，函数能够记住自己定义时候的外部环境和内容语句

闭包定义：有权访问外部作用域的函数

数组：数组可以保存任何数据，还可以保存函数

## 类数组对象：

使用方式类似于数组的一类对象

可以通过索引值访问数据，有length属性，表示数据个数。如`arguments`

arguments存储的是实参，与形参无关

类数组对象不是数组，因此不能使用数组方法

## 数组对象：

对象是特征和行为的集合；由{ }包裹的名值对，中间用逗号隔开。是一个无序的数据集合。

如：`{name:"dafei",age:20}`

对象的创建方式：

```
字面量：var obj={	}
```

自定义对象属性和方法的设置与获取

获取对象的属性：

```
obj.attr:常用的方式

obj['attr']:当属性是变量的时候，使用这种方式
```

使用for...in便利对象

删除对象的属性：

```
delete obj.attr
```

### 遍历对象：

for和for...in

```
注意：
	for循环遍历数组，索引值是数字
	for...in循环遍历数组，索引值是字符串
	工作中常用for循环遍历数组和类数组，用for...in遍历对象
```

注意：引用类型的数据不能使用typeof去判断，我们学习的数组、类数组、对象、函数原则上来讲都是对象：null代表空对象

## JSON（JavaScript Object Notationt,JS对象简谱）：

是一种轻量级的数据交换格式。基于ECMAScript的一个子集，采用完全独立于编程语言的，简介和清晰的层次结构使得JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效的提升网络传输的效率。JSON键值对是用来保存JS对象的一种方式，和JS对象的写法类似

JSON和JS对象的关系：JSON是JS对象的字符串表示法，他使用文本表示一个JS对象的信息，本质是一个字符串。如：

```
var obj={a:"hello",b:"world"}//这是一个对象

var JSON='{"A":"hello","b":"world",v:12}'//这是个JSON字符串，本质是一个字符串
```

## JSON字符串与JS对象之间的转换：

JSON.stringfy(obj)将一个对象转换成字符串形式：

​		`undefined，NaN，Infinity和null会转化为null,函数会被过滤掉`

JSON.parse(str)将一个字符串转化为对象

在JS中，一切都是对象。因此，任何支持的类型都可以通过JSON来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型

注意：JSON不能存储函数

## this:

this表示执行函数时候的上下文对象，实在执行函数时确定的

注意：this通常在函数的内部使用。

​			 在浏览器端，全局的this指向window。

# 6. 正则表达式：

## 字符串：

`length`属性：表示字符的长度。字符串的所有字符的个数（字母、汉字、数字、标点、特殊字符、空格）

`charAt( )`：表示通过字符串指定位置返回该位置的编码值。参数：指定位置，也是从0开始的。返回值：该位置的值。

`charCodeAt( )`：返回字符串指定位置字符的编码 

`indexOf( )`：返回指定值的首次出现的索引值。如果字符串没有该值返回-1 

`concat( )`：字符串拼接。用于多个字符串的拼接。参数灵活，可以写字面量、变量、散的值。

`split( )`：字符串转化为数组。（数组中的每一项认识字符串）

`toUpperCase( )`：将字母转换为大写字母

`toLowerCase( )`：将字母转换为小写字母

`slice(start,end)`：字符串的截取方法，从start到end(不包括end)。start和end都是字符串的索引值。可以是整数也可以是负数。

`substr(start,howmany)`：表示字符串的截取方法。从start开始截取howmany个字符串。返回截取的字符串。howmany:可以不写，表示截取到最后

`substring(start,end)`：表示从start开始截取到end(不包括end)。参数不可以写负数。可以不区分start和end的顺序（包括小索引值不包括大索引值）

## 正则表达式（regular expression - RegExp）：

是被用来匹配字符串中的字符组合的模式。是最简单的数据（字符串）验证方式。常用于表单的验证。

创建方法：使用正则字面量。/表达式/。

正则数据类型：引用数据类型，因此也提供一些方法：

exec( ):用于将首次匹配到的字符串以数组的方式输出。没有全局匹配。没有满足条件的将返回null。

test( ):用于检测字符串中是否有正则表达式匹配的字符串。

​			返回值：

​						true：满足条件

​						false：不满足条件

## 正则的字符串方法：

split( ):用匹配的字符切割父字符串返回切割后字符组成的数组。使用字符串切割。参数：使用正则

match( ):

search( ):用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子字符串的起始位置

replace( ):用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串

## 正则表达式的术语和操作符：

正则表达式的组成：由普通字符和特殊字符（元字符）组成。

​			普通字符：字母、数字；

​			特殊字符：（）、{ }、\、|、^、$、?、+、. 

正则中特殊字符必须使用转义字符 ‘\\’。

精确匹配：表示匹配的字符只含有普通字符。

预定义特殊字符：\n 换行符  \t制表符

修饰符：写在正则表达式后面，如：//g;

```
g:执行全局匹配        //有几个就匹配几个
i:忽略大小写的匹配     
m:多行匹配
```

正则表达式——字符集：

```
简单类：直接书写所有可能
范围类：表示一类可能性。[0-9]、[a-Z]、[A-Z]
组合类：表示不同类型的组合。[0-9A-z]、[a-zA-Z]
负向类：表示不包含后面书写匹配字符串的可能性。如：[^0-9]
```

## 边界：

```
^ :开头匹配。表示以"^"之后的字符串作为开头的匹配
$ :结尾匹配。表示以"$"之前的字符串结尾的匹配
\b:单词边界。用于查找位于单词的开头或者结尾的匹配
\B:非单词边界。用于查找不处于单词开头或者结尾的匹配
```

## 量词：

用于处理一系列紧密相连的同类型数据，通过{ }定义量词

```
{n}	:	硬性量词。表示出现n次。
{n,m}:	软性量词。表示至少出现n次，最多不超过m次。
{n,}:	表示至少出现n次。
+	:	表示至少出现一次。{1,}
*	:	表示出现0次或者多次。{0,}
?	:	表示出现0次或者1次 。{0,1}
```

## 分组：

或操作符：' | '表示可能性，如a|b|c

用于处理多个重复的数据，通过（）定义分组

分组的反问引用:表示正则表达式匹配的字符串再次进行使用。\编号（正则表达式中使用,前后值一样），$编号（正则表达式外使用，如：$1,$2）。编码从1开始，一次进行分组的编码。1,2,3……

一个分组就是一个编码。只能在正则中使用。

非捕获组：不会创建反向引用的分组

（?=exp）:表示其后紧跟指定字符串的字符串

（?!exp）:表示其后没有紧跟字符串的字符串

## 预定义类：

JS提前定义好的，一些特殊字符。表示一类字符，是一些特殊字符集的简写。

```javascript
.	:[^\n\r]表示除了换行、回车之外的任意字符
\d	:[0-9]表示数字
\D	:[^0-9]表示非数字
\s	:[\t\n\xOB\f\r]表示空白字符
\S	:[^\t\n\xOB\f\r]表示非空白字符
\w	:[a-zA-Z_0-9]表示单词、字符（所有的字母、数字、下划线）
\W	:[^a-zA-Z_0-9]表示非单词字符
匹配中文:[\u4e00-\u9fa5]，是一个固定用法，中文只能在正则表达式里这样表示。
```

## 定时器：

### 单次定时器：间隔一段时间后异步执行。

异步：脱离主程序线程，单独执行，不会堵塞后面程序的执行

启动单次定时器：setTimeout				清除单次定时器：clearTimeout

### 循环定时器：每一段时间，函数自动执行一次

启动循环定时器：setInterval				  清除循环定时器：clearInterval

setTimeout与setinterval的参数需要两个

```javascript
#第一个：每一段时间要做的事情书写在函数内部。可以是匿名函数或者是函数名。
#第二个：函数间隔多长时间。单位是:ms。不用书写单位：1s=1000ms。
#定时器调用的对象是Window。但是一般不写window。表示页面加载之后立即调用定时器。
	setTimeout(function(){
		console.log("hello");
    },2000)//2s后打印hello

#clearTimeout与clearInterval参数：定时器的名字
#回调函数：给方法传递的参数函数
	let timerbar=setTimeout(function(){
        console.log("world");
    },2000)
    clearTimeout
```

**注意：重启循环定时器时，一定要先清除原有的定时器，否则会造成定时器叠加**

## 对应与排他：

一般用一个元素去控制其他元素。根据他们之间的联系（索引值相同）进行书写。

排他：选中的元素改变其他元素，让其他元素变回原状：如：选项卡的实现

# 7. 函数进阶、

# 8. DOM基础：

## DOM：

(Document Obiect Model):文档对象模型

## HTML操作：

document：表示文档（整个页面）对象。document对象具有页面几乎所有的方法或者属性。

```javascript

读取：document.tittle:获取页面的标题

赋值：document.tittle="hello"：给标题赋值

```

一般操作都是从获取元素开始的。

获取元素的方法：document.getElementById( )通过id属性获取元素对象

通过id 获取元素的数据类型是对象

```

读取:document.getElementById( )

赋值:document.getElementById( )="122"

'.'语法只能读取或者设置元素自带的属性不能设置读取元素的自定义属性
```

## 属性操作：

### 属性操作方法：

读取：getAttribute( )可以读取元素自带属性或者是自定义属性

设置：setAttribute( )可以设置元素自带的属性或是自定义属性

' . ' 语法和getAttribute( )、setAttribute( )的区别：

​	（1）：' . ' 语法只能读取或设置元素的自带属性，getAttribute( )、setAttribute( )读取、设置元素自带属性或者是自定义属性

​	（2）： . ' 语法操作有些属性需要改名字，getAttribute( )、setAttribute( )不用改名，如

​				class-->className              for-->htmlFor

​				rowspan-->rowSpan            colspan-->colSPan

​	（3）:通过' . '语法得到的style是对象，而getAttribute( )得到的是字符串。

​	（4）：' . '语法得到的style可以继续打点。而getAttribute( )得到的是字符串不能继续打点调用属性。

总结：除了自定义属性使用getAttribute( )，其他的都用' . '语法进行操作

## 样式操作：

通过' . '语法获得style对象（包括css所有的样式）。能够继续打点调用style属性

属性名改为驼峰式命名法（删除横线，将横线后面的单次首写字母大写）

读取：' . '语法获得style对象中的css样式

设置：使用' = '进行设置，添加新的属性。如: document.getElementById("").style.color="red"

还可通过setAttribute方法修改样式，会覆盖原有的样式

## getElementByTagName( ):

getElementsByClassName( ):不兼容IE低版本

getElementsByTagName( ):兼容IE低版本，通过元素标签名获得元素，得到的是页面上所有的同种标签组成的类数组对象。

​			类数组中保存的每一个数据也是一个对象。

​			得到的类数组对象具有length属性。表示保存的同种标签的元素个数。

​			可以通过数组的索引值得到任何一个对象。

类数组对象保存数据的顺序和标签之间的嵌套没有关系，和标签首次出现的顺序有关。

批量操作事件：

​		通过getElementByTagName( )得到的类数组对象，我们可以通过批量操作的方式给每一个元素添加相同的事件

注意：事件回调函数中，存储索引值的方式有两种：

​			1.利用IIFE和闭包实现对数据的存储

```javascript
var divs=document.getElementsByTagName("div")
for(var i=0;i<div.length;i++){
    divs[i].onclick=(function(a){
        console.log(a)
    })(i+1);
}
```



​			2.通过this访问元素自身存储的数据

```javascript
for(var i=0;i<div.length;i++){
    divs[i].onclick=function(){
        //this指向函数调用者
        console.log(this.)
    }
}
```

## 样式的计算：

计算后的样式：指的是HTML元素在css各种选择器综合的情况下，得到的最终样式。

高级浏览器的方法：windows.getComputerStyle( ),该方法接收一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。该返回接口提供一个.getPropertyValue（）方法，用于检索特定样式属性的计算样式。

.getPropertyValue方法:接收的是css属性名称，而不是驼峰式命名

```javascript
document.getElementById("").getPropertyValue("font-size");
document.getElementById("").getPropertyValue("color");
document.getElementById("").getPropertyValue("width");

```



IE6、7、8方法：

低版本的浏览器不认识.getComputerStyle( )。IE低版本的计算方法：currentStyle( 对象打点调用)。currentStyle也可以直接使用[ ]得到计算后的样式属性。注意：不管是中括号还是点语法都只能用驼峰式命名。

```javascript
document.getElementById("").currentStyle.color;
document.getElementById("").currentStyle.fontSize;
document.getElementById("").currentStyle.width;
document.getElementById("").currentStyle.backgroundColor;
```

## DOM事件：

事件监听：在解析JS代码时，会去看某一些元素是否添加了事件。随时监听这些时间有没有触发，如果触发则执行对应操作。

| DOM事件      |              |
| ------------ | ------------ |
| onclick      | 单击鼠标     |
| ondbclick    | 双击鼠标     |
| onmouseenter | 鼠标进入     |
| onmouseleave | 鼠标离开     |
| onmousedown  | 鼠标按下     |
| onmouseup    | 鼠标弹起     |
| onfoucs      | 获取焦点     |
| onblur       | 失去焦点     |
| onload       | 加载完毕之后 |
|              |              |

元素绑定事件：元素.事件名 = function。可以绑定匿名函数或者函数名(不要再函数名后面谢小括号)。

注意：

​		（1）：我们在body中书写JS代码时，需要将JS书写在所有HTML元素之后，当HTML元素加载完毕后再执行

​		（2）：如果JS书写在head标签中，必须谢onload事件，window.onload表示当HTML元素加载完毕之后执行内部语句。

# *9. jQuery详解、

# 10. DOM进阶:

## ECMAScript是核心语法：

里面包含如何定义变量、运算符、表达式、流程控制语句、数据类型

## DOM:(document object model)文档对象模型：

体现在代码中的document

## BOM:(broswer object model)浏览器对象模型：

体现在代码中的window

## 节点类型：

### 对于DOM的操作：

通过dom的onclick、onmousedown、onmouseup来添加事件

通过dom的getElementById获取元素

通过dom的style来设置样式

### DOM是由节点组成的，元素/标签：是节点中的某一种，节点一共分为12种：

```javascript

元素节点：	    Node.ELEMENT_NODE(1)

属性节点：	    Node.ATTRIBUTE_NODE(2)

文本节点：		Node.TEXT_NODE(3)

CDATA节点：	 Node.CDTA_SECTION_NODE(4)

实体引用名称节点：Node.ENTRY-REFERENCE_NODE(5)

实体名称节点：	  Node.ENTITY_NODE(6)

处理指令节点：   Node.PROCESSING_INSTRUCTION_NODE(7)

注释节点：      Node.COMMENT_NODE(8)

文档节点：      Node.DOCUMENT_NODE(9)

文档类型节点：	  Node.DOCUMENT_TYPE_NODE(10)

文档片段节点：	  Node.DOCUMENT_FRAGMENT_NODE(11)

DTD声明节点：	Node.NOTATION_NODE(12)
```

**每一个元素都是一个节点，但是每一个节点不一定是一个元素，元素仅仅是节点的一种：**

通过nodeType属性判断节点的类型

我们需要记住的有四种：

:feet:**元素类型**：1

:feet:**文本类型**：3

:feet:**注释类型**：8

*​***:feet:文档类型**：9

childNodes属性：该属性指向一个子节点的所有子节点的集合

### 节点属性：

**nodeType:标记的是节点的类型**

**nodeName:标记的是节点的名称**

**nodeValue:标记的是节点的值**

### 总结：

节点的名称：

```
元素：元素名称大写

文本：#text

注释：#comment
```



节点的值：

```
元素：null

文本：文本内容

注释：注释的内容
```

### 节点的关系

#### 父子关系：

father.childNodes:获取所有的子节点

father.firstChild:获取第一个子节点

father.lastChild:获取最后一个子节点

#### 子父关系：

child.parentNodes:获取到父节点

#### 兄弟关系：

node.nextSibling:获取到下一个兄弟节点

node.previousSibing:获取到上一个兄弟节点

# 11.BOM对象

BOM（Browser Object Model）浏览器对象模型，是JavaScript的重要组成部分。提供一系列对象用于与浏览器窗口进行交互，这些对象通常称为BOM

`window`是窗口对象。表示整个浏览器窗口，主要用来操作浏览器窗口。同时window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有的原生构造函数及其他函数也都存在于它的命名空间下

`document`对象：是window对象的一个属性，可以用来处理页面文档

`location`对象：用于获得当前页面的地址（URL），并把浏览器重定向到新的页面

​			`localtion.herf`='URL地址'

​			`location.hostname`：返回web主机的域名

​			`location.pathname`：返回当前页面的路径和文件名

​			`location.port`：返回web主机的端口（http默认端口号：80或https默认端口号：443）

​			`location.portocol`返回页面使用的web协议，HTTP或HTTPS：

`navigator`对象：提供了与浏览器有关的信息。userAgent是最常用的属性，用来完成浏览器的判断。

​			注意：（window.navigator对象在编写的时候不可以使用window这个前缀）

`screen`对象：用来获取用户的屏幕信息

​			`height`：获取整个屏幕的高度

​			`width`：获取整个屏幕的宽度

​			`availHeight`：整个屏幕的高度减去系统部件的高度（可用的高度）

​			`availWidth`：整个屏幕的宽度减去系统部件的宽度（可用的宽度）

`history`对象：包含浏览器的历史

​			来源页：`document.referrer`

​			`back()`：返回上一页

​			`forward()`：返回下一页

​			`go(参数)`：-1表示上一页，1表示下一页:go(1);go(-1)



# 12. 事件详解、

# 13. 面向对象开发